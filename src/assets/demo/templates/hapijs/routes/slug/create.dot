{{ function defaultValue(f) {
  if (f.nullable) return "null";
  if (f.type === "boolean") return "false";
  if (f.type === "string") return "''";
  if (f.type === "number") return "0";
  if (f.type === "datetime") return "Date.now()";
  return "null";
}
}}{{ function joiValidator(f) {
    let out = "Joi.";

    if (f.type === "boolean") out += "boolean()";
    else if (f.type === "string") out +=  "string().trim()";
    else if (f.type === "number" || f.type === "datetime") out +=  "number()";
    else if (f.type === "entity") out +=  "string().length(24).hex()";
    else out +=  "any()";

    if (f.nullable) out += ".allow(null)";
    else  out += ".required()";

    return out;
  }
}}'use strict';
/**
 * Create {{=it.m.names.wordsLower}}.
 * Returns the created {{=it.m.names.wordsLower}}.
 */

const Joi = require('joi');
const Boom = require('boom');
{{?it.m.f.r.length}}
const MongoDB = require('mongodb');
{{?}}

// Validation schema for payload
const schema = Joi.object({
{{~it.m.f.f(f => !f.internal) : f}}
    {{=f.names.underscore}}: {{ out += joiValidator(f); }},
{{~}}
});

/**
 * Get MongoDB results or scream if no insertion has been done
 *
 * @param {Object} error
 * @returns {Function}
 */
const screamIfNoInsertion = (error) => (r) => (r.insertedCount === 0 ? Promise.reject(error) : r.ops[0]);

/**
 * Export route to create {{=it.m.names.wordsLower}}
 */
module.exports = {
    method: 'POST',
    path: '/{{=it.m.names.hyphen}}',
    config: {
        validate: { payload: schema },
        description: 'Route to create {{=it.m.names.wordsLower}}',
        tags: ['{{=it.m.names.hyphen}}', 'create']
    },
    handler: (request, reply) => {

        // Get {{=it.m.names.wordsLower}} from payload
        const {{=it.m.names.underscore}} = request.payload;

{{?it.m.f.i.filter(f => !f.primary).length}}

        // Init internal fields
{{~it.m.f.i.filter(f => !f.primary) : i}}
        {{=it.m.names.underscore}}.{{=i.names.underscore}} = {{ out += defaultValue(i); }};
{{~}}
{{?}}

{{?it.m.f.r.f(r => !r.internal).length}}

        // Convert reference fields
{{~it.m.f.r.f(r => !r.internal) : r}}
        {{=it.m.names.underscore}}.{{=r.names.underscore}} = typeof request.payload.{{=r.names.underscore}} === 'string' ?
            new MongoDB.ObjectId(request.payload.{{=r.names.underscore}}) : null;
{{~}}
{{?}}

        // Insertion options
        const options = { w: 'majority' };

        // Insert {{=it.m.names.wordsLower}} into database
        request.server.db.collection('{{=it.m.names.underscore}}')
            .insertOne({{=it.m.names.underscore}}, options)
            .then(screamIfNoInsertion(Boom.internal('Insert error')))
            .then((result) => {

                const {{=it.m.names.underscore}} = result;

{{?it.m.f.ip.length}}

                // Delete private properties
{{~it.m.f.ip : p}}
                delete {{=it.m.names.underscore}}.{{=p.names.underscore}};
{{~}}
{{?}}


{{?it.m.f.r.f(r => !r.isPrivate).length}}

                // Convert reference fields
                const promises = [];
{{~it.m.f.r.f(r => !r.isPrivate) : r}}

                // Append {{=r.names.wordsLower}}
                if (result.{{=r.names.underscore}}) {
{{?r.m.f.ip.length}}
                    const projection{{=r.names.upperCamel}} = { {{~r.m.f.ip : f}}
                        {{=f.names.underscore }}: false,{{~}}
                    };
{{?}}
                    promises.push(request.server.db.collection('{{=r.m.names.underscore}}')
                      .findOne({ {{=r.m.f.p.names.underscore}}: new MongoDB.ObjectId(result.{{=r.names.underscore}}) }{{?r.m.f.ip.length}}, projection{{=r.names.upperCamel}}{{?}})
                      .then((reference) => {
                        {{=it.m.names.underscore}}.{{=r.names.underscore}} = reference;
                      }));
                }
{{~}}

                // Run promises
                return Promise.all(promises)
                  .then(() => {
                    reply({{=it.m.names.underscore}}).code(201);
                  });
{{??}}

                reply({{=it.m.names.underscore}}).code(201);
{{?}}
            })

{{?it.m.f.u.length}}
            .catch((e) => {
                // Handle duplicated key for unique indexes
                if (e.name === 'MongoError' && e.code === 11000) {
                    return reply(Boom.conflict('Duplicate key'));
                }

                // Otherwise, wrap the error
                return reply(Boom.boomify(e));
            });
{{??}}
            .catch((e) => reply(Boom.boomify(e)));
{{?}}

    }
};

