{{ function defaultValue(f) {
  if (f.type === "boolean") return "false";
  if (f.type === "string") return "''";
  if (f.type === "number") return "0";
  return "null";
}
}}{{ function joiValidator(f) {
    if (f.type === "boolean") return "boolean()";
    if (f.type === "string") return "string()";
    if (f.type === "number") return "number()";
    if (f.type === "entity") return "string().length(24).hex()";
    return "null";
  }
}}'use strict';
/**
 * Create {{=it.m.names.wordsLower}}.
 * Returns the created {{=it.m.names.wordsLower}}.
 */

const Joi = require('joi');
const Boom = require('boom');{{?it.m.f.r.length}}
const MongoDB = require('mongodb');{{?}}

// Validation schema for payload
const schema = Joi.object({ {{~it.m.f.l : f}}{{?!f.internal}}
    {{=f.names.underscore}}: Joi.{{ out += joiValidator(f); }}.required(),{{?}}{{~}}
});

/**
 * Get MongoDB results or scream if no insertion has been done
 *
 * @param {Object} error
 * @returns {Function}
 */
const screamIfNoInsertion = (error) => (r) => (r.insertedCount === 0 ? Promise.reject(error) : r.ops[0]);

/**
 * Export route to create {{=it.m.names.wordsLower}}
 */
module.exports = {
    method: 'POST',
    path: '/{{=it.m.names.hyphen}}',
    config: {
        validate: { payload: schema },
        description: 'Route to create {{=it.m.names.wordsLower}}',
        tags: ['{{=it.m.names.hyphen}}', 'create']
    },
    handler: (request, reply) => {

        // Get {{=it.m.names.wordsLower}} from payload
        const {{=it.m.names.underscore}} = request.payload;
{{?it.m.f.i.length}}
        // Init internal fields{{~it.m.f.i : i}}{{?!i.primary}}
        {{=it.m.names.underscore}}.{{=i.names.raw}} = {{ out += defaultValue(i); }};{{?}}{{~}}
{{?}}{{?it.m.f.r.length}}
        // Convert reference fields{{~it.m.f.r : r}}
        {{=it.m.names.underscore}}.{{=r.names.raw}} = new MongoDB.ObjectId(request.payload.{{=r.names.underscore}});{{~}}
{{?}}
        // Insertion options
        const options = { w: 'majority' };

        // Insert {{=it.m.names.wordsLower}} into database
        request.server.db.collection('{{=it.m.names.underscore}}')
            .insertOne({{=it.m.names.underscore}}, options)
            .then(screamIfNoInsertion(Boom.internal('Insert error')))
            .then((result) => {

                const {{=it.m.names.underscore}} = result;
{{?it.m.f.ip.length}}
                // Delete private properties{{~it.m.f.ip : p}}
                delete {{=it.m.names.underscore}}.{{=p.names.raw}};{{~}}
{{?}}{{?it.m.f.r.length}}
                // Convert reference fields
                const promises = [];{{~it.m.f.r : r}}
                // Append {{=r.names.wordsLower}}
                promises.push(request.server.db.collection('{{=r.m.names.underscore}}')
                  .findOne({ {{=r.m.f.p.names.raw}}: new MongoDB.ObjectId(result.{{=r.names.raw}}) })
                  .then((reference) => {{{?r.m.f.ip.length}}
                    // Delete private properties{{~r.m.f.ip : p}}
                    delete reference.{{=p.names.raw}};{{~}}
{{?}}
                    {{=it.m.names.underscore}}.{{=r.names.raw}} = reference;
                  }));{{~}}

                // Run promises
                return Promise.all(promises)
                  .then(() => {
                    reply({{=it.m.names.underscore}}).code(201);
                  });
{{?}}{{?!it.m.f.r.length}}
                reply({{=it.m.names.underscore}}).code(201);
{{?}}
            })
            .catch((e) => reply(Boom.boomify(e)));
    }
};

