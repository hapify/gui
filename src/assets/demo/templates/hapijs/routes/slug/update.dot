{{ function joiValidator(f) {
    let out = "Joi.";

    if (f.type === "boolean") out += "boolean()";
    if (f.type === "string") out +=  "string().trim()";
    if (f.type === "number" || f.type === "datetime") out +=  "number()";
    if (f.type === "entity") out +=  "string().length(24).hex()";

    if (f.nullable) out += ".allow(null)";

    return out;
  }
}}'use strict';
/**
 * Update {{=it.m.names.wordsLower}}
 */

const Joi = require('joi');
const Boom = require('boom');
const MongoDB = require('mongodb');

// Validation schema for params
const schemaParams = Joi.object({
    {{=it.m.f.p.names.underscore}}: Joi.string().length(24).hex().required()
});
// Validation schema for payload
const schemaPayload = Joi.object({ {{~it.m.f.f(f => !f.internal) : f}}
    {{=f.names.underscore}}: {{ out += joiValidator(f); }},{{~}}
}).min(1);

/**
 * Get MongoDB results or scream if no update has been done
 *
 * @param {Object} error
 * @returns {Function}
 */
const screamIfNoUpdate = (error) => (r) => (r.value === null ? Promise.reject(error) : r.value);

/**
 * Export route to update {{=it.m.names.wordsLower}}
 */
module.exports = {
    method: 'PATCH',
    path: '/{{=it.m.names.hyphen}}/{{{=it.m.f.p.names.underscore}}}',
    config: {
        validate: {
            params: schemaParams,
            payload: schemaPayload
        },
        description: 'Route to update {{=it.m.names.wordsLower}}',
        tags: ['{{=it.m.names.hyphen}}', 'update']
    },
    handler: (request, reply) => {

        // Get updates from payload
        const updates = { $set: request.payload };

        // Get {{=it.m.names.wordsLower}} {{=it.m.f.p.names.wordsLower}}
        const {{=it.m.f.p.names.underscore}} = new MongoDB.ObjectId(request.params.{{=it.m.f.p.names.underscore}});
{{?it.m.f.r.f(r => !r.internal).length}}
        // Convert reference fields{{~it.m.f.r.f(r => !r.internal) : r}}
        {{=it.m.names.underscore}}.{{=r.names.underscore}} = typeof request.payload.{{=r.names.underscore}} === 'string' ?
            new MongoDB.ObjectId(request.payload.{{=r.names.underscore}}) : null;{{~}}
{{?}}
        // Insertion options
        const options = { w: 'majority' };

        // Update {{=it.m.names.wordsLower}} in database
        request.server.db.collection('{{=it.m.names.underscore}}')
            .findOneAndUpdate({ {{=it.m.f.p.names.underscore}} }, updates, options)
            .then(screamIfNoUpdate(Boom.notFound('{{=it.m.names.wordsUpper}} not found')))
            .then(() => {
                reply().code(204);
            }){{?it.m.f.u.length}}
            .catch((e) => {
                // Handle duplicated key for unique indexes
                if (e.name === 'MongoError' && e.code === 11000) {
                  return reply(Boom.conflict('Duplicate key'));
                }

                // Otherwise, wrap the error
                return reply(Boom.boomify(e));
            });{{?}}{{?!it.m.f.u.length}}
            .catch((e) => reply(Boom.boomify(e)));{{?}}
    }
};

