{{ function _type(f) {
  if (f.type === "boolean") return "string | boolean";
  if (f.type === "string") return "string";
  if (f.type === "number") return "string | number";
  if (f.type === "datetime") return "string | number | Date";
  if (f.type === "entity") return "string";
  return "any";
}
function _interface(f) {
    const prop = f.names.underscore;
    const type = _type(f);
    let line = `${prop}?: ${type}`;
    if (f.type === "number" || f.type === "datetime") {
        line += `;\n  ${prop}__min?: ${type}`;
        line += `;\n  ${prop}__max?: ${type}`;
    }
    return line;
}
function _key(f) {
    const prop = f.names.underscore;
    let line = `'${prop}'`;
    if (f.type === "number" || f.type === "datetime") {
        line += `,\n  '${prop}__min'`;
        line += `,\n  '${prop}__max'`;
    }
    return line;
}
}}import {Subject} from 'rxjs/Subject';
import {Helpers} from '@app/shared';

/**
 * Used to export and import search params
 */
export interface {{=it.m.names.upperCamel}}SearchParamsInterface {{{~it.m.f.se : f}}
  {{ out += _interface(f); }};{{~}}
  _page?: string | number;
  _limit?: string | number;
  _sort?: string;
  _order?: string;
}

/**
 * List allowed keys for the interface
 *
 * @type {string[]}
 * @private
 */
const AllowedKeys: string[] = [{{~it.m.f.se : f}}
  {{ out += _key(f); }},{{~}}
  "_page",
  "_limit",
  "_sort",
  "_order"
];

/**
 * Manage {{=it.m.names.wordsLower}} search params
 */
export class {{=it.m.names.upperCamel}}SearchParams extends Subject<void> {

  /**
   * Stores the properties of the instance
   */
  props: {{=it.m.names.upperCamel}}SearchParamsInterface;

  /**
   * Default page number
   *
   * @type {number}
   */
  defaultPage = 0;

  /**
   * Default page length
   *
   * @type {number}
   */
  defaultLimit = 10;

  /**
   * Constructor
   */
  constructor() {
    super();
    // Create from nothing
    this.fromObject({});
  }

  /**
   * Populate the instance from an object (extracted from query string)
   *
   * @param {{{=it.m.names.upperCamel}}SearchParamsInterface} input
   */
  fromObject(input: {{=it.m.names.upperCamel}}SearchParamsInterface): void {

    // Clone object with allowed keys only
    const props: {{=it.m.names.upperCamel}}SearchParamsInterface = {};
    AllowedKeys.map((key: string) => {
      if (typeof input[key] !== 'undefined')
        props[key] = input[key];
    });

    // Keep default values
    if (typeof props._page === 'undefined') props._page = this.defaultPage;
    if (typeof props._limit === 'undefined') props._limit = this.defaultLimit;
{{~it.m.f.se : f}}{{? f.type === 'boolean' }}
    // Convert boolean {{=f.names.wordsLower}}
    if (typeof props.{{=f.names.underscore}} !== 'undefined')
      props.{{=f.names.underscore}} = Helpers.convertToBoolean(props.{{=f.names.underscore}});
{{?}}{{~}}{{~it.m.f.se : f}}{{? f.type === 'datetime' }}
    // Convert dates for {{=f.names.wordsLower}}
    if (typeof props.{{=f.names.underscore}} !== 'undefined')
      props.{{=f.names.underscore}} = Helpers.convertToDate(props.{{=f.names.underscore}});
    if (typeof props.{{=f.names.underscore}}__min !== 'undefined')
      props.{{=f.names.underscore}}__min = Helpers.convertToDate(props.{{=f.names.underscore}}__min);
    if (typeof props.{{=f.names.underscore}}__max !== 'undefined')
      props.{{=f.names.underscore}}__max = Helpers.convertToDate(props.{{=f.names.underscore}}__max);
{{?}}{{~}}
    // Assign values
    this.props = props;
    this.next();
  }

  /**
   * Convert the instance to an object readable for the API and storable in the query string
   *
   * @return {{{=it.m.names.upperCamel}}SearchParamsInterface}
   */
  toObject(): {{=it.m.names.upperCamel}}SearchParamsInterface {

    // Filter not allowed, undefined and null values
    const props: {{=it.m.names.upperCamel}}SearchParamsInterface = {};
    AllowedKeys.map(Helpers.prepareObjectForApi(this.props, props));
{{~it.m.f.se : f}}{{? f.type === 'datetime' }}
    // Avoid conflict in value of {{=f.names.wordsLower}}
    if (typeof props.{{=f.names.underscore}} !== 'undefined') {
      delete props.{{=f.names.underscore}}__min;
      delete props.{{=f.names.underscore}}__max;
    }
{{?}}{{~}}{{~it.m.f.se : f}}{{? f.type === 'boolean' }}
    // Convert boolean {{=f.names.wordsLower}}
    if (typeof props.{{=f.names.underscore}} !== 'undefined')
      props.{{=f.names.underscore}} = props.{{=f.names.underscore}} ? "true" : "false";
{{?}}{{~}}

    return props;
  }

}
